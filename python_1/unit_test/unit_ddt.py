# _*_ coding:utf-8 _*_
# @Time    :2019/5/27 17:07
# @Author  :xiuhong.guo
# @Email   :892336120@qq.com
# @File    :unit_date.py

# 测试用例数据的复用性：安装 pip install ddt
# ddt：data driver test 数据驱动测试

# 装饰器：如 @staticmethod   @classmethod
# ddt模块中也有装饰器：如 ddt  data  unpack，这些装饰器本身也是个函数，即装饰器函数
# @ddt：是装饰器函数，装饰测试类 unittest.TestCase 的子类
# @data：是装饰器函数，装饰测试类 unittest.TestCase 的子类中的方法
# @data的函数作用：
# 1.data函数中要传的参数是个动态参数，所以传进去的数据是个元组
# 2.与for循环类似，把传进来的数据进行迭代，也就是遍历作用，把每一个数据都遍历一次，
# 然后传给下面装饰的测试用例方法，有几条数据，就执行几次被装饰的测试用例
# @unpack ：
# 1.把传进用例方法中的每一条数据进行拆分，如：把[1,2]这个列表拆分成了1和2两个参数，再一次性传递，会分别传给下面方法中的两个参数
# 2.如果拆分的数据是个字典，那么被装饰的用例方法必须用字典中的key来作为参数名接收

import unittest
# 导入ddt模块中的ddt,data,unpack，ddt,data,unpack这三个函数都是装饰器
from ddt import ddt,data,unpack # 导入模块中的不同类或函数等用逗号隔开

@ddt # @ddt是装饰器函数，装饰测试类 unittest.TestCase 的子类
class TestAdd(unittest.TestCase):
    # 遍历元组，传递给方法中的一个参数
    @data(1,2,3,4,5) # @data是装饰器函数，装饰测试类 unittest.TestCase 的子类中的方法
    # data函数中要传的参数是个动态参数，所以传进去的数据是个元组
    # 跟for循环一样，遍历元组(1,2,3,4,5)中的每一个数据，把1,2,3,4,5分别传递给下面装饰的方法test_001，
    # 有几条数据，就执行几次被装饰的测试用例
    def test_001(self,a): # 会执行5次该测试用例，@data函数中传了5个数据
        print(a)

    # 遍历有列表的元组，传递给方法中的一个参数
    @data([1,2]) # 只传了一个参数，是个元组中有个列表[1,2]
    def test_002(self, a):  # 会执行1次该测试用例，@data函数中传了1个列表数据
        print(a,a[0],a[1])

    # 遍历有列表的元组，并拆分数据，传递给方法中的多个参数
    @data([1,2]) # 只传了一个参数，是个元组中有个列表[1,2]
    # @data(*[1, 2]) # 拆分数据不能直接在前面加*解包，因为解包完变成了(1,2)，成了有2个数据的元组，
    # 会遍历传2次给下面的方法，所以解决办法是加@unpack这个拆分装饰器
    @unpack # 把传进用例方法中的每一条数据进行拆分，这里把[1,2]这个列表拆分成了1和2两个参数，一次性传递，且会分别传给a,b
    def test_003(self, a,b):  # 会执行1次该测试用例，@data函数中传了1个列表数据
        print(a,b)

    # 加上解包的遍历元组，并拆分数据，传递给方法中的多个参数
    @data(*[[1,2],[3,4]])
    @unpack
    def test_004(self, a,b):
        print(a,b)

    # 遍历含有字典的元组，并拆分数据，传递给方法中的多个参数
    # 把传递的字典进行拆分后，被装饰的用例方法必须用字典中的key来接收
    @data(*[{'a':0,'b':0,'expected':0},{'a':1,'b':1,'expected':1}])
    @unpack
    def test_005(self, a, b,expected): # 如果传递的是字典，要用它的key来作为参数进行接收
        print(a, b,expected)

    # 遍历含有列表的元组，并拆分数据，传递给方法中的多个参数，但每个传进来的值拆分后的参数个数不一样
    # 第一种方式：没有的那个参数可以给个默认值None
    @data(*[[0,1,2,3],[1,2,3]])
    @unpack
    def test_005(self, a, b,c,d=None):
        print(a,b,c,d)

    # 遍历含有列表的元组，并拆分数据，传递给方法中的多个参数，但每个传进来的值拆分后的参数个数不一样
    # 第二种方式：没有的那个参数可用动态参数接收
    @data(*[[0,1,2,3],[1,2,3]])
    @unpack
    def test_005(self, a, b,c,*d):
        print(a,b,c,d)

# 总结：
# 如：1.@data([[1,2],[3,4]]):data里面的数据传进来，传进来的是个元组，有1个元素，执行1条用例
# 2.@data(*[[1,2],[3,4]]):data里面的数据传进来，传进来的是个元组，加上*号，进行解包，有2个元素，执行2条用例
# 3.@data(*[[1,2],[3,4]])  @unpack:加上unpack拆分装饰器，把元组中的每一个列表值传进来，再拆分成了2个参数，测试用例方法要用2个参数来进行接收
# 4.@data(*[{'a':0,'b':0,'expected':0},{'a':1,'b':1,'expected':1}])  @unpack:
# 加上unpack拆分装饰器，把元组中的每一个字典值传进来，再拆分成了3个参数，测试用例方法要用3个参数来进行接收，且参数名称要与传进来的字典中的key一致
# 5.@data(*[[0,1,2,3],[1,2,3]]) @unpack：每个传进来的值拆分后的参数个数不一样，在测试用例方法的参数中，可能没有的那个参数可以写成默认参数，给个默认值None，def test_005(self, a, b,c,d=None):
# 或者 可能没有的那个参数可以写成动态参数，如def test_005(self, a, b,c,*d):
# 6.运行过程中，要把鼠标放在类外执行，不然会报方法不存在，原因是加了ddt，单独执行某个测试用例方法时，无法识别ddt